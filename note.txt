Day 3:
- when we call PostQuitMessage(errorCode) it sends the WM_QUIT message to the message loop and message processing should terminate. We can handle the WM_QUIT message before the loop stops
- GDI - windows graphics api

- use VirtualProtect() to change the protection of memory pages to MEM_NOACCESS so if there is any stale pointers to that memory and are read or written to, we can track them

- in this code
	windowClass.lpfnWndProc = Win32MainWindowCallback;
	windowClass.hInstance = Instance; // or GetModuleHandle(0);

Day 5:
- the callback and hInstance is passed to the window class. Windows needs to know which process is holding the function, because that function is in the process's addess space. Every process's address space is different so every pointer does not uniquely identify memory in the system, but in the process. So without the process handle windows will not know which process called the callback. So the hInstance is the actual process that contains the callback address.

- the WM_PAINT message is sent from windows when it needs to repaint the window in situations like moving the window down and part of it is obscure and move it back up, windows remembers the obscrured region of the window and it send to our program the message to repaint it. And in the WM_PAINT we need to at least handle the message with BeginPaint() and EndPaint() so that windows know that we handled the repaint message. If we dont handle it at least in that way, it will keep sending the WM_PAINT message until we do and it will flood the message queue.
